// Code generated by protoc-plugin-http. DO NOT EDIT.
// versions:
// - protoc-plugin-http v0.1.1
// - protoc  v3.19.4
// source: test/test.proto

package test

import (
	context "context"
	errors "errors"
	gin "github.com/gin-gonic/gin"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// TestGinServer is the server API for Test service.
// All implementations must embed UnimplementedTestGinServer
// for forward compatibility
type TestGinServer interface {
	Update(ctx context.Context, req *UpdateTestRequest) (*UpdateTestReply, error)
	Delete(ctx context.Context, req *DeleteTestRequest) (*emptypb.Empty, error)
	List(ctx context.Context, req *ListTestRequest) (*ListTestReply, error)
	Get(ctx context.Context, req *GetTestRequest) (*GetTestReply, error)
	Create(ctx context.Context, req *CreateTestRequest) (*CreateTestReply, error)
	mustEmbedUnimplementedTestGinServer()
}

// UnimplementedTestGinServer must be embedded to have forward compatible implementations.
type UnimplementedTestGinServer struct {
}

func (UnimplementedTestGinServer) Update(ctx context.Context, req *UpdateTestRequest) (*UpdateTestReply, error) {
	return nil, gin.Error{Type: gin.ErrorTypePublic, Err: errors.New(http.StatusText(http.StatusNotImplemented))}
}
func (UnimplementedTestGinServer) Delete(ctx context.Context, req *DeleteTestRequest) (*emptypb.Empty, error) {
	return nil, gin.Error{Type: gin.ErrorTypePublic, Err: errors.New(http.StatusText(http.StatusNotImplemented))}
}
func (UnimplementedTestGinServer) List(ctx context.Context, req *ListTestRequest) (*ListTestReply, error) {
	return nil, gin.Error{Type: gin.ErrorTypePublic, Err: errors.New(http.StatusText(http.StatusNotImplemented))}
}
func (UnimplementedTestGinServer) Get(ctx context.Context, req *GetTestRequest) (*GetTestReply, error) {
	return nil, gin.Error{Type: gin.ErrorTypePublic, Err: errors.New(http.StatusText(http.StatusNotImplemented))}
}
func (UnimplementedTestGinServer) Create(ctx context.Context, req *CreateTestRequest) (*CreateTestReply, error) {
	return nil, gin.Error{Type: gin.ErrorTypePublic, Err: errors.New(http.StatusText(http.StatusNotImplemented))}
}
func (UnimplementedTestGinServer) mustEmbedUnimplementedTestGinServer() {}

// UnsafeTestGinServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestGinServer will
// result in compilation errors.
type UnsafeTestGinServer interface {
	mustEmbedUnimplementedTestGinServer()
}

type TestGinRouter = gin.IRoutes

func RegisterTestGinServer(r TestGinRouter, srv TestGinServer) {
	r.GET("/account/:id/:c_asa_2c_3/:kk/aa:*", _Test_List0_Gin_Handler(srv))
	r.POST("/as/a/::id", _Test_List1_Gin_Handler(srv))
	r.GET("/account/:id", _Test_Get0_Gin_Handler(srv))
	r.POST("/account", _Test_Create0_Gin_Handler(srv))
	r.PUT("/account/:id", _Test_Update0_Gin_Handler(srv))
	r.DELETE("/account", _Test_Delete0_Gin_Handler(srv))
}

func _Test_List0_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(ListTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.List(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Test_List1_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(ListTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.List(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Test_Get0_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(GetTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.Get(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Test_Create0_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(CreateTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.Create(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Test_Update0_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(UpdateTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.Update(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Test_Delete0_Gin_Handler(srv TestGinServer) gin.HandlerFunc {
	return func(c *gin.Context) {
		req := new(DeleteTestRequest)
		// param bind and validate
		if err := c.Bind(req); err != nil {
			return
		}
		// response body
		res, err := srv.Delete(c, req)
		if err != nil {
			c.Abort()
			c.Error(err)
			return
		}
		_Output_Gin_Test(c, res)
	}
}

func _Output_Gin_Test(c *gin.Context, res any) {
	accept := strings.ToLower(c.GetHeader("Accept"))
	switch {
	case strings.Contains(accept, "application/x-protobuf") || strings.Contains(accept, "application/protobuf"):
		c.ProtoBuf(http.StatusOK, res)
	case accept == "*/*" || strings.Contains(accept, "application/json"):
		c.JSON(http.StatusOK, res)
	case strings.Contains(accept, "application/xml") || strings.Contains(accept, "text/xml"):
		c.XML(http.StatusOK, res)
	default:
		c.JSON(http.StatusOK, res)
	}
}

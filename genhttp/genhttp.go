package genhttp

import (
	"fmt"

	"github.com/cnartlu/protoc-gen-go-http/genhttp/frames"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type gen struct {
	// omitempty 是否允许空值
	omitempty bool
	// version 版本号
	version string
	// _frame 框架
	_frame string
	// plugin 插件
	plugin *protogen.Plugin
	// file proto 文件
	file *protogen.File
	// g 生成输出文件
	g *protogen.GeneratedFile
	// frame 框架
	frame frames.Frame
}

func (c *gen) SetOmitempty(omitempty bool) *gen {
	c.omitempty = omitempty
	return c
}

func (c *gen) SetVersion(version string) *gen {
	c.version = version
	return c
}

func (c *gen) SetFrame(frame string) *gen {
	c._frame = frame
	return c
}

func (c *gen) SetPlugin(plugin *protogen.Plugin) *gen {
	c.plugin = plugin
	return c
}

func (c *gen) SetFile(file *protogen.File) *gen {
	c.file = file
	return c
}

// hasHTTPRule 是否存在http路由
func (c *gen) hasHTTPRule() bool {
	for _, service := range c.file.Services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
			if rule != nil && ok {
				return true
			}
		}
	}
	return false
}

// checkAllowGenerateFile 检查是否允许创建文件
func (c *gen) checkAllowGenerateFile() bool {
	if len(c.file.Services) == 0 || (c.omitempty && !c.hasHTTPRule()) {
		return false
	}
	return true
}

func (c *gen) protocVersion() string {
	v := c.plugin.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (c *gen) generateFile() error {
	if !c.checkAllowGenerateFile() {
		return nil
	}
	c.g.P("// Code generated by protoc-plugin-http. DO NOT EDIT.")
	c.g.P("// versions:")
	c.g.P(fmt.Sprintf("// - protoc-plugin-http %s", c.version))
	c.g.P("// - protoc  ", c.protocVersion())
	if c.file.Proto.GetOptions().GetDeprecated() {
		c.g.P("// ", c.file.Desc.Path(), " is a deprecated file.")
	} else {
		c.g.P("// source: ", c.file.Desc.Path())
	}
	c.g.P()
	c.g.P("package ", c.file.GoPackageName)
	c.g.P()
	// 输出错误代码
	for _, service := range c.file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			c.g.P("//")
			c.g.P("// Deprecated: Do not use.")
		}
		if err := c.frame.Generate(c.plugin, c.file, c.g, service, c.omitempty); err != nil {
			return err
		}
	}
	return nil
}

func (c *gen) Generate() error {
	if !c.checkAllowGenerateFile() {
		return nil
	}
	c.frame = frames.GetFrame(c._frame)
	if c.frame == nil {
		return fmt.Errorf("frame %s not found", c._frame)
	}
	fileRouter := c.file.GeneratedFilenamePrefix + "_" + c._frame + ".pb.go"
	c.g = c.plugin.NewGeneratedFile(fileRouter, c.file.GoImportPath)
	return c.generateFile()
}

func New() *gen {
	return &gen{}
}
